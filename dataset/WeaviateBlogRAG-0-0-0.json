[
    {
        "source": "Note, the current implementation of hybrid search in Weaviate uses BM25/BM25F and vector search. If you\u2019re interested to learn about how dense vector indexes are built and optimized in Weaviate, check out this [article](/blog/why-is-vector-search-so-fast). ### BM25\nBM25 builds on the keyword scoring method [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) (Term-Frequency Inverse-Document Frequency) by taking the [Binary Independence Model](https://en.wikipedia.org/wiki/Binary_Independence_Model) from the IDF calculation and adding a normalization penalty that weighs a document\u2019s length relative to the average length of all the documents in the database. The image below presents the scoring calculation of BM25:\n![BM25 calculation](./img/BM25-calculation.png) <div align=\"center\"><i>Source: Wikipedia page on Okapi BM25</i></div>\n\nThe score of the document, query pair is determined by weighing the uniqueness of each keyword in the query relative to the collection of texts. BM25 contains additional static parameters, k1 and b that may help calibrate performance to particular datasets.",
        "query": "What is the role of the Binary Independence Model in the BM25 algorithm used by Weaviate's hybrid search?",
        "gold_answer": "The Binary Independence Model in the BM25 algorithm used by Weaviate's hybrid search plays a crucial role in the calculation of the Inverse Document Frequency (IDF). It is used to weigh the uniqueness of each keyword in the query relative to the collection of texts by adding a normalization penalty that weighs a document\u2019s length relative to the average length of all the documents in the database. This helps in determining the score of the document, query pair, thereby aiding in the retrieval of relevant documents."
    },
    {
        "source": "Updatability: The index data is immutable, and thus no real-time updates are possible. 2. Scalability: Most vector libraries cannot be queried while importing your data, which can be a scalability concern for applications that require importing millions or even billions of objects. Thus, vector libraries are a great solution for applications with a limited static snapshot of data. However, if your application requires real-time scalable semantic search at the production level, you should consider using a vector database.",
        "query": "Why might vector libraries not be suitable for applications that require real-time updates and scalable semantic search?",
        "gold_answer": "Vector libraries might not be suitable for applications that require real-time updates and scalable semantic search because they have immutable index data, preventing real-time updates. They also cannot be queried while importing data, posing a scalability concern for applications that need to import large amounts of data. Furthermore, they lack full CRUD support, which is necessary for real-time scalable semantic search."
    },
    {
        "source": "I recommend checking out the GitHub repository to test this out yourself!\n\n## Additional Resources\n\u2022 [LangChain Guide](https://www.commandbar.com/blog/langchain-projects) by Paul from CommandBar. import StayConnected from '/_includes/stay-connected.mdx'\n\n<StayConnected />",
        "query": "What guide does the document recommend for learning about LangChain projects?",
        "gold_answer": "The document recommends the \"LangChain Guide\" by Paul from CommandBar for learning about LangChain projects."
    },
    {
        "source": "If we compress the vectors then the memory requirements goes down to the 1572 MB to 2129 MB range. After compression, recall drops to values ranging from 0.7337 to 0.9545. Latency rises up to the 7521 to 37402 microsends range. A summary is shown in Table 3 below. |                       |              | Recall100@100 | Latency ($\\mu s$)         | Memory required (MB)         |\n|-----------------------|--------------|---------------|---------------------------|------------------------------|\n| Sift1M Low params     | Uncompressed | 0.91561       | 293                       | 1277                         |\n|                       | Compressed   | 0.91361       | 401               (x1.36) | 610                 (47.76%) |\n| Sift1M High params    | Uncompressed | 0.99974       | 1772                      | 1674                         |\n|                       | Compressed   | 0.99658       | 1937             (x1.09)  | 1478               (88.29%)  |\n| DeepImage Low params  | Uncompressed | 0.8644        | 827                       | 9420                         |\n|                       | Compressed   | 0.85666       | 1039             (x1.25)  | 4730               (50.21%)  |\n| DeepImage High params | Uncompressed | 0.99757       | 2601                      | 15226                        |\n|                       | Compressed   | 0.97023       | 2708             (x1.04)  | 12367             (81.22%)   |\n| Gist Low params       | Uncompressed | 0.74461       | 2133                      | 4218                         |\n|                       | Compressed   | 0.73376       | 7521             (x3.52)  | 1572              (37.26%)   |\n| Gist High params      | Uncompressed | 0.99628       | 15539                     | 5103                         |\n|                       | Compressed   | 0.95455       | 37402           (x2.40)   | 2129               (41.72%)  |\n\n**Tab.",
        "query": "What is the percentage reduction in memory requirements for the Gist dataset with low parameters after compression?",
        "gold_answer": "The percentage reduction in memory requirements for the Gist dataset with low parameters after compression is approximately 62.74%."
    },
    {
        "source": "### Testing queries\n\nSemantic (`nearText`) searches may be one of the most common (if not *the* most common) searches our users perform. So let's see how we might test semantic searches. A semantic search requires vectorizing the query, so a test will validate the integration with the vectorizer (`text2vec-openai` in this case). We'll run a query for \"chemistry\" and check that the top result is about \"sodium\". :::info Will the top result always be the same?",
        "query": "How do you test semantic search functionality and result consistency using `text2vec-openai`?",
        "gold_answer": "To test semantic search functionality and result consistency using `text2vec-openai`, you would run a query and check the top result. For example, if you run a query for \"chemistry\", you might check if the top result is about \"sodium\". However, due to the nature of semantic search and language understanding, the top result may not always be the same. This could be due to various factors such as the complexity of the query, the database's content, and the specific algorithms used in the `text2vec-openai` module. Therefore, testing should involve running multiple queries and checking the relevance and consistency of the results."
    },
    {
        "source": "For sure it might not be for everybody and every use case. But if you are using Weaviate at scale, in production, we believe enabling it will add significant value and encourage you to consider its use.",
        "query": "What does the document recommend for users running Weaviate at scale in production?",
        "gold_answer": "The document recommends that users running Weaviate at scale in production should enable its use due to the significant value it can add. They should consider the flexibility it offers during ingestion time, such as extracting PDFs or applying stemming to their BM25 and hybrid search. Users should also take advantage of Weaviate's ability to handle large-scale performance, run complex queries with strict latency requirements, and its advanced monitoring and replication capabilities. The document also suggests using Weaviate's unique search features to drive performance and efficiency."
    },
    {
        "source": "Since around [80% of all data is unstructured](https://www.forbes.com/sites/forbestechcouncil/2019/01/29/the-80-blind-spot-are-you-ignoring-unstructured-organizational-data/), it is hard to actually search and retrieve insights from most of the data. The Weaviate vector database unlocks the potential of unstructured data. Searching by fuzzy terms and classification of rich data like free text becomes possible with Weaviate. It uses AI-driven indexing and search technologies to enable real-time text processing. With machine learning methods, Weaviate automatically classifies texts.",
        "query": "What percentage of data is unstructured, and how does Weaviate help in processing it?",
        "gold_answer": "Around 80% of all data is unstructured. Weaviate helps in processing unstructured data by using AI-driven indexing and search technologies for real-time text processing. It also uses machine learning methods to automatically classify texts, making it possible to search and retrieve insights from unstructured data."
    },
    {
        "source": "Particularly from my conversation with Nils Reimers, I have become very interested in the continual learning nature of this. For example, when we released the `ref2vec` module and discussed it on the podcast, the `all-miniLM-L6-v2` model has never seen ref2vec before in its training set. Additionally, a model fine-tuned up to podcast #30 will have never seen ref2vec either!\n\n    I am also very interested in the fine-tuning of cross-encoder models, which you can learn more about [here](/blog/cross-encoders-as-reranker). 3. Custom Benchmarking\n\n\tI have also been working on the BEIR benchmarking in Weaviate (nearly finished!).",
        "query": "What module was discussed on the podcast that the `all-miniLM-L6-v2` model had not been trained on?",
        "gold_answer": "The module that was discussed on the podcast that the `all-miniLM-L6-v2` model had not been trained on is `ref2vec`."
    },
    {
        "source": "In other words, the User vector is being updated in real-time here to take into account their preferences and actions, which helps to produce more relevant results at speed. Another benefit of Ref2Vec is that this calculation is not compute-heavy, leading to low overhead. With Ref2Vec, you can use Weaviate to provide Recommendation with \"user-as-query\". This is a very common and powerful way to build Home Feed style features in apps. This can be done by sending queries like this to Weaviate:\n\n```graphql\n{\n  Get {\n    Product (\n      nearObject: {\n        id: \"8abc5-4d5...\" # id for the User object with vector defined by ref2vec-centroid\n      }\n    ) {\n      product_name\n      price\n    }\n  }\n}\n```\n\nThis short query encapsulates the power of Ref2Vec.",
        "query": "What is Ref2Vec, and how does it integrate with Weaviate to provide real-time user-based recommendations?",
        "gold_answer": "Ref2Vec is a method that infers a centroid vector from a user's references to other vectors. This vector is updated in real-time to reflect the user's preferences and actions. Ref2Vec integrates with Weaviate through the \"user-as-query\" method, where the user's vector is used as a query to fetch relevant products. This method ensures that the user's vector remains up-to-date with their latest interests, providing personalized recommendations with low computational overhead. Ref2Vec also helps in overcoming the cold-start problem by providing personalization to new users after a few interactions on the app."
    },
    {
        "source": "We have three documents labeled `A`, `B`, and `C` and have run a BM25 and Dense search. In this example, we have set the constant *k* to 0. | BM25 Ranking | Dense Ranking | Results\n| --- | --- | --- |\n| A | B | A: 1/1 + 1/3 = 1.3 |\n| B | C | B: 1/2 + 1/1 = 1.5 |\n| C | A | C: 1/3 + 1/2 = 0.83|\n\nThe above table shows the ranked order of the BM25 and Dense search. To fuse the two lists together, we need to take the sum of the reciprocal ranks. Based on the results, the top document is `Document B` with a ranking of 1.5, then `Document A` at 1.3, and `Document C` at 0.83.",
        "query": "How are BM25 and Dense search rankings combined using reciprocal ranks, and what is the resulting order of documents A, B, and C?",
        "gold_answer": "The BM25 and Dense search rankings are combined using reciprocal ranks by calculating the sum of the reciprocal ranks of each document in both lists. The resulting order of documents, from highest to lowest ranking, is B, A, C."
    },
    {
        "source": "The IDE shows us the available options and their descriptions. import invertedIndexHintsImgUrl from './img/inverted-index-hints.png';\n\n<img src={invertedIndexHintsImgUrl} alt=\"Tool tip hints for inverted index configurations\" width=\"85%\"/>\n\nTypes are introduced for the data objects as well at creation time, as well as when retrieving them from the database. This means that you can access the properties of the data object directly. So syntax that is currently like this:\n\n:::note Classic client syntax\n```python\nresponse['data']['Get']['Article'][0]['title']  # Get the `title` property of the first object\nresponse['data']['Get']['Article'][0]['_additional']['id']  # Get the ID of the first object\nresponse['data']['Get']['Article'][0]['_additional']['generate']['singleResult']  # Get the generated text from a `singlePrompt` request\nresponse['data']['Get']['Article'][0]['_additional']['generate']['groupedResult']  # Get the generated text from a `groupedTask` request\n```\n\n:::\n\nBecome:\n\n:::info `Collections` client syntax\n\n```python\nresponse.objects[0].properties['title']  # Get the `title` property of the first object\nresponse.objects[0].uuid  # Get the ID of the first object\nresponse.objects[0].generated  # Get the generated text from a `singlePrompt` request\nresponse.generated  # Get the generated text from a `groupedTask` request\n```\n\n:::\n\nWe think that these changes will reduce errors, increase productivity, and make the code easier to read and understand. ### Collections-first approach\n\nThe other big change is that the `collections` client focuses on individual collections for interaction.",
        "query": "What are the syntax differences between the classic client and the collections client for accessing data object properties in the described programming environment?",
        "gold_answer": "The syntax differences between the classic client and the collections client for accessing data object properties are as follows:\n\n- In the classic client, the syntax for accessing the `title` property of the first object is `response['data']['Get']['Article'][0]['title']`, while in the collections client, the syntax is `response.objects[0].properties['title']`.\n- In the classic client, the syntax for getting the ID of the first object is `response['data']['Get']['Article'][0]['_additional']['id']`, while in the collections client, the syntax is `response.objects[0].uuid`.\n- In the classic client, the syntax for getting the generated text from a `singlePrompt` request is `response['data']['Get']['Article'][0]['_additional']['generate']['singleResult']`, while in the collections client, the syntax is `response.objects[0].generated`.\n- In the classic client, the syntax for getting the generated text from a `groupedTask` request is `response['data']['Get']['Article'][0]['_additional']['generate']['groupedResult']`, while in the collections client, the syntax is `response.generated`."
    },
    {
        "source": "It significantly outperforms baseline multimodal models such as DALL-E and CM3 on both image and caption generation tasks. 2. It requires much less compute while achieving better performance (<30% of DALLE)\n3. MM-RAG capable models also generate images much more faithful to the retrieved context - meaning the quality of the generated images is better and grounded in the retrieved context image. 4.",
        "query": "Which model outperforms DALL-E and CM3 in image and caption generation tasks while requiring less computational power and producing images more faithful to the retrieved context?",
        "gold_answer": "The model that outperforms DALL-E and CM3 in image and caption generation tasks while requiring less computational power and producing images more faithful to the retrieved context is MM-RAG."
    },
    {
        "source": "---\ntitle: An Overview on RAG Evaluation\nslug: rag-evaluation\nauthors: [erika, connor]\ndate: 2023-11-21\ntags: [concepts]\nimage: ./img/hero.png\ndescription: \"Learn about new trends in RAG evaluation and the current state of the art.\"\n---\n![hero](img/hero.png)\n\n<!-- truncate -->\n\nRetrieval Augmented Generation (RAG) is picking up steam as one of the most popular applications of Large Language Models and Vector Databases. RAG is the process of augmenting inputs to a Large Language Model (LLM) with context retrieved from a vector database, like [Weaviate](https://weaviate.io/). RAG applications are commonly used for chatbots and question-answering systems. Like any engineering system, evaluating performance is crucial to the development of RAG applications. The RAG pipeline is broken down into three components: 1.",
        "query": "What is Retrieval Augmented Generation and what are its common applications?",
        "gold_answer": "Retrieval Augmented Generation (RAG) is a process that uses a vector database to store and retrieve object embeddings, allowing a language model to read relevant information before generating a response. This enables the scaling of the knowledge of large language models without the need for constant training or fine-tuning. The benefits of RAG include scalability, accuracy, controllability, and interpretability. Common applications of RAG include chatbots and question-answering systems."
    },
    {
        "source": "More importantly, every tenant has a dedicated high-performance vector index providing query speeds as if the tenant was the only user on your cluster. With more features in the pipeline, such as tenant-specific rate limiting or tenant-specific replication factors, you can customize performance per tenant even further. ### GDPR-compliant and efficient deletes\nWhen discussing solutions made for many users, our first intuition is to worry about how we onboard and serve them. But deleting them is equally important \u2013 both for technical and legal reasons. Take GDPR as an example.",
        "query": "How does the system ensure fast query speeds for individual tenants and what upcoming features will allow further customization of tenant performance?",
        "gold_answer": "The system ensures fast query speeds for individual tenants by providing each tenant with a dedicated high-performance vector index and allowing for resource isolation. Upcoming features that will allow further customization of tenant performance include tenant-specific rate limiting and tenant-specific replication factors."
    },
    {
        "source": "The below `curl` command will back up all classes in **W1**, and call the backup `my-very-first-backup`. ```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n     \"id\": \"my-very-first-backup\"\n    }' \\\nhttp://localhost:8080/v1/backups/filesystem\n```\n\n:::note The `backup_id` must be unique. The ID value is used to create a subdirectory in the backup location, and attempting to reuse an existing ID will cause Weaviate to throw an error. Delete the existing directory if one already exists. :::\n\nNow try running `3_backup` yourself to back up data from **W1**.",
        "query": "How do you create a unique backup called `my-very-first-backup` for classes in W1 using a curl command?",
        "gold_answer": "To create a unique backup called `my-very-first-backup` for classes in W1 using a curl command, you would use the following command:\n\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n     \"id\": \"my-very-first-backup\"\n    }' \\\nhttp://localhost:8080/v1/backups/filesystem\n```\n\nThis command sends a POST request to the Weaviate server to create a backup of all classes in W1. The backup is identified by the unique `id` `my-very-first-backup`."
    },
    {
        "source": "Then, you just run the queries, as per usual:\n```javascript\nnearText = {\n    \"concepts\": [\"How to use Hugging Face modules with Weaviate?\"],\n    \"distance\": 0.6,\n}\n\nresult = (\n    client.query\n    .get(\"Notes\", [\n        \"name\",\n        \"comment\",\n        \"_additional {certainty distance} \"])\n    .with_near_text(nearText)\n    .do()\n)\n```\n\n## Summary\n> Now you can use [Hugging Face](/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-huggingface) or [OpenAI](/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-openai) modules in Weaviate to delegate model inference out. Just pick the model, provide your API key and start working with your data. Weaviate optimizes the communication process with the Inference API for you, so that you can focus on the challenges and requirements of your applications. No need to run the Inference API yourself. ## What next\nCheck out the [text2vec-huggingface](/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-huggingface) documentation to learn more about the new module.",
        "query": "How can I use Hugging Face modules with Weaviate without running the Inference API myself?",
        "gold_answer": "To use Hugging Face modules with Weaviate without running the Inference API yourself, you need to have Weaviate version 1.15 or newer. In the configuration, set `DEFAULT_VECTORIZER_MODULE` and `ENABLE_MODULES` to `text2vec-huggingface`. This will enable the Hugging Face module, allowing you to use the Hugging Face Inference service with sentence similarity models to vectorize and query your data directly from Weaviate."
    },
    {
        "source": "And additionally, Weaviate often interacts with external services such as vectorizers or LLMs.\n\nSuch complexity makes it important to test the application as a whole, and not just its individual components. This complexity also means that arranging the test suite can be cumbersome with a variety of moving parts that need to be set up and torn down. [Embedded Weaviate](/developers/weaviate/installation/embedded) makes one part of this puzzle much easier, since Weaviate can be instantiated directly from the client. The following is all you need to do to start a Weaviate server:\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python\">\n  <FilteredTextBlock\n    text={PyCode}\n    startMarker=\"# START Connect\"\n    endMarker=\"# Client is now ready to accept requests\"\n    language=\"py\"\n  />\n  </TabItem>\n\n  <TabItem value=\"js\" label=\"JavaScript/TypeScript\">\n  <FilteredTextBlock\n    text={TSCode}\n    startMarker=\"// START Connect\"\n    endMarker=\"// Client is now ready to accept requests\"\n    language=\"js\"\n  />\n  </TabItem>\n</Tabs>\n\nThis is not only useful for new contributors to the project, but also for experienced developers. Starting anew as a new contributor, or working from a different machine on occasion, can be a hassle.",
        "query": "How does Embedded Weaviate simplify the setup process for testing the Weaviate application?",
        "gold_answer": "Embedded Weaviate simplifies the setup process for testing the Weaviate application by eliminating the need to set up and tear down a separate service such as a database. This makes the testing process less time-consuming and less prone to errors. Additionally, it allows for a more robust testing process that can verify various operations such as data import, vectorization, and export, as well as search, insertion, updates, deletes, and other operations that are part of the user journey."
    },
    {
        "source": "You can reach us through:\n\n- Join our dedicated Hacktoberfest channel in our [Discourse community forum](https://forum.weaviate.io/), where we're ready to answer your questions. - Join our dedicated #hacktoberfest channel in our [Weaviate Community Slack](https://weaviate.slack.com/) channel to stay connected and receive real-time support. - Join our [newsletter](https://newsletter.weaviate.io/) and follow us on [Twitter](https://twitter.com/weaviate_io) and [Linkedin](https://www.linkedin.com/company/weaviate-io/mycompany/verification/) to receive updates. - Stay up to date with Weaviate's development by exploring the [Weaviate GitHub Repository](https://github.com/weaviate/weaviate). Don\u2019t forget to give us a \u2b50\ufe0f while you are there!\n\n:::info Pro Tip\nShare your process online and tag us on [Twitter](https://twitter.com/weaviate_io) and [LinkedIn](https://nl.linkedin.com/company/weaviate-io).",
        "query": "How can I participate in the Weaviate community's Hacktoberfest event and stay updated on their developments?",
        "gold_answer": "To participate in the Weaviate community's Hacktoberfest event, you can join their dedicated Hacktoberfest channel in their Discourse community forum or their #hacktoberfest channel in their Weaviate Community Slack channel. To stay updated on their developments, you can join their newsletter and follow them on Twitter and Linkedin. You can also explore the Weaviate GitHub Repository. They also encourage you to share your process online and tag them on Twitter and LinkedIn."
    },
    {
        "source": "You would need the following ingredients:\n* Raw Data\n* Hugging Face API token \u2013 which you can request from [their website](https://huggingface.co/settings/tokens)\n* A working Weaviate instance with the `text2vec-huggingface` enabled\n\nThen you would follow these steps. ### Step 1 \u2013 initial preparation \u2013 create schema and select the hf models\nOnce you have a Weaviate instance up and running. Define your schema (standard stuff \u2013 pick a class name, select properties, and data types). As a part of the schema definition, you also need to provide, which Hugging Face model you want to use for each schema class. This is done by adding a `moduleConfig` property with the `model` name, to the schema definition, like this:\n```javascript\n{\n    \"class\": \"Notes\",\n    \"moduleConfig\": {\n        \"text2vec-huggingface\": {\n            \"model\": \"sentence-transformers/all-MiniLM-L6-v2\",  # model name\n            ...",
        "query": "How do you set up a Weaviate instance with the `text2vec-huggingface` module?",
        "gold_answer": "To set up a Weaviate instance with the `text2vec-huggingface` module, follow these steps:\n\n1. Set `text2vec-huggingface` as the default vectorizer in the Weaviate configuration by setting the `DEFAULT_VECTORIZER_MODULE` and `ENABLE_MODULES` environment variables to `text2vec-huggingface`.\n\n2. Ensure you have the necessary \"ingredients\", which include raw data, a Hugging Face API token, and a working Weaviate instance with the `text2vec-huggingface` module enabled.\n\n3. Define your schema by picking a class name, selecting properties, and data types. As part of the schema definition, specify which Hugging Face model you want to use for each schema class by adding a `moduleConfig` property with the `model` name to the schema definition.\n\n4. Run queries as usual."
    },
    {
        "source": "`go_memstats_heap_inuse_bytes` should always be present even with an empty schema. ![datadog summary](./img/datadog-summary.png)\n\n\n## Key Metrics\n\nBelow are some key Weaviate metrics to monitor. Standard CPU, Disk, Network metrics are also useful as are [Kubernetes\nevents](https://grafana.com/blog/2023/01/23/how-to-use-kubernetes-events-for-effective-alerting-and-monitoring/). Note that some Weaviate metrics will not appear until an operation has occurred (for instance batch operations). ### Heap Usage\n\nFor heap usage, the expectation is the memory will have a standard jagged pattern underload but that memory will drop periodically\ndue to the Go garbage collection.",
        "query": "Should the `go_memstats_heap_inuse_bytes` metric be present in Weaviate even if the schema is empty, and what is its expected behavior under load?",
        "gold_answer": "Yes, the `go_memstats_heap_inuse_bytes` metric should be present in Weaviate even if the schema is empty. Its expected behavior under load is to have a standard jagged pattern, growing as more data is imported but dropping periodically due to the Go garbage collection. If the memory usage is consistently close to the GOMEMLIMIT, it may indicate that more resources are needed."
    },
    {
        "source": "One of the primary reasons is the computational cost associated with processing and storing longer sequences of tokens. The longer the sequence, the more memory and processing power required to operate on it, which can be a significant challenge for even the most powerful computing systems. The relatively long input window of LLMs is what drives the integration with semantic search. For example, we can use this entire blog post as input in addition to questions if we want the LLM to answer questions such as \u201cWhat are LLM Chains?\u201d However, when we want to give the LLM an entire book or pages of search results, we need more clever techniques to decompose this task. This is where the `CombineDocuments` chain comes to play! Note, that one method is not better than another, and the performance is dependent solely on your application.",
        "query": "Why are techniques like the `CombineDocuments` chain necessary for processing large texts with LLMs?",
        "gold_answer": "Techniques like the `CombineDocuments` chain are necessary for processing large texts with LLMs because they help overcome the limitations of LLMs in handling long sequences of tokens. They do this by breaking down larger texts into smaller, manageable chunks that can be processed by the LLM without overwhelming its computational and memory capacities."
    },
    {
        "source": "To see a list of the newly spun up nodes, run:\n\n```shell\nkubectl get nodes -o wide\n```\n\nYou should see an output similar to the following, indicating that three nodes are up and onto which you can deploy Weaviate:\n\n```shell\nNAME           STATUS   ROLES           AGE    VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION     CONTAINER-RUNTIME\nminikube       Ready    control-plane   134m   v1.27.3   192.168.49.2   <none>        Ubuntu 22.04.2 LTS   5.15.49-linuxkit   docker://24.0.4\nminikube-m02   Ready    <none>          134m   v1.27.3   192.168.49.3   <none>        Ubuntu 22.04.2 LTS   5.15.49-linuxkit   docker://24.0.4\nminikube-m03   Ready    <none>          133m   v1.27.3   192.168.49.4   <none>        Ubuntu 22.04.2 LTS   5.15.49-linuxkit   docker://24.0.4\n```\n\nNow, add the Weaviate helm repository to your local helm configuration by running:\n\n```shell\nhelm repo add weaviate https://weaviate.github.io/weaviate-helm\n```\n\nAnd save the default configuration with:\n\n```shell\nhelm show values weaviate/weaviate > values.yaml\n```\n\nEdit `values.yaml` by changing the root-level configuration `replicas: 1` for the root image to `replicas: 3`, and save it. ```yaml\n... # Scale replicas of Weaviate. Note that as of v1.8.0 dynamic scaling is limited\n# to cases where no data is imported yet. Scaling down after importing data may\n# break usability.",
        "query": "How can I check the status and details of nodes in a Kubernetes cluster and prepare to deploy Weaviate with three replicas?",
        "gold_answer": "To check the status and details of nodes in a Kubernetes cluster, run the command `kubectl get nodes -o wide`. To prepare to deploy Weaviate with three replicas, add the Weaviate helm repository to your local helm configuration by running `helm repo add weaviate https://weaviate.github.io/weaviate-helm`, save the default configuration with `helm show values weaviate/weaviate > values.yaml`, and edit `values.yaml` by changing the root-level configuration `replicas: 1` for the root image to `replicas: 3`. Then, create a namespace for Weaviate and deploy it using the `helm upgrade --install` command."
    },
    {
        "source": "For more information about this new feature, read this [blog post](/blog/ref2vec-centroid) by Connor Shorten. Weaviate also has a bunch of example use cases on [GitHub](https://github.com/weaviate/weaviate-examples). Find your favorite example, give it a star, and try to recreate it yourself!\n\n## Feature Comparison - Library versus Database\nThe table below summarizes the differences between vector libraries and databases. This is by no means an exhaustive list of features, and not every library or database has the same features. |**Feature**|**Vector Library**|**Vector Database** (Weaviate as an example)|\n| ----- | ----- | ----- |\n| Filtering (in combination with Vector Search)| No| Yes|\n| Updatability (CRUD)| No (some do, e.g. hnswlib)| Yes|\n| Incremental importing, concurrent reading while importing| No (some do, e.g. hnswlib) | Yes |\n| Stores objects and vectors | No | Yes|\n|Speed | Typically faster than full-blown database|  Typically slower than pure library|\n| Performance optimized for | In-memory similarity search| End2end-callstack, including: vector search, object retrieval from persistent storage, optional inverted index filtering, network requests, etc.",
        "query": "What are the differences between vector libraries and vector databases like Weaviate in terms of features such as filtering, updatability, and performance?",
        "gold_answer": "The differences between vector libraries and vector databases like Weaviate include filtering (supported by Weaviate but not typically by vector libraries), updatability (supported by Weaviate but not typically by vector libraries), incremental importing and concurrent reading while importing (supported by Weaviate but not typically by vector libraries), storage of objects and vectors (supported by Weaviate but not by vector libraries), and speed and performance (vector libraries are typically faster and optimized for in-memory similarity search, while Weaviate is slower and optimized for end-to-end call stack)."
    },
    {
        "source": "![Cross-Encoder](./img/cross-encoder.png)\n\n*Figure 3 - Representation of a Cross-Encoder model*\n\n\nIf a Cross-Encoder model is trained on a representative training set, it [achieves higher accuracy than Bi-Encoders](https://arxiv.org/abs/1908.10084). However, since you need to use the Cross-Encoder model during a search for every single data item in combination with the query, this method is very inefficient. For a real-life semantic search application \u2013 with thousands or millions of objects \u2013 this would be impractical, as it would take \"forever\" to perform the search. ## Combining Bi-Encoders and Cross-Encoders\n\nWe can combine the two methods to benefit from the strong points of both models! I'd like to illustrate this idea with an example. Imagine you are a fisherman who is looking for salmon in a sea full of fish of numerous species.",
        "query": "Why are Cross-Encoders considered impractical for semantic search applications with large datasets?",
        "gold_answer": "Cross-Encoders are considered impractical for semantic search applications with large datasets because they are computationally expensive and time-consuming. For every single data item in the dataset, the Cross-Encoder model needs to be used in combination with the query, making this method very inefficient when dealing with large datasets. The time it would take to perform the search with such large datasets would be impractical."
    },
    {
        "source": "In other words, GOMEMLIMIT is precisely the missing piece that we outlined before. If the live heap is low (e.g., 100MB), we can delay the next GC cycle until the heap has doubled (200MB). But if the heap has grown close to our limit (e.g., 4GB), the GC runs more often to prevent us from ever running OOM. ### Why a soft limit? What is the difference between a soft and a hard limit?",
        "query": "What is the role of GOMEMLIMIT in garbage collection cycles, and how does it differ when the live heap is low versus when it is near the limit?",
        "gold_answer": "GOMEMLIMIT plays a crucial role in managing garbage collection cycles in the Go runtime. It serves as a soft limit that the memory usage aims to stay within. When the live heap is low, the garbage collector can delay the next cycle until the heap has doubled. However, when the heap is close to the GOMEMLIMIT, the garbage collector runs more frequently to prevent the program from running out of memory."
    },
    {
        "source": "In addition to these two models, however, you can use any model from the Hugging Face Hub (or your own) by following [this guide](/developers/weaviate/modules/reader-generator-modules/sum-transformers#use-another-summarization-module-from-hugging-face). Even when looking only at language models that are trained for summarization tasks, there is still a wide range of choices in terms of sheer numbers, which vary in the target domain (e.g. medical, legal, scientific, etc.) and size (number of parameters, i.e. speed). If you have specific needs, we recommend investigating other models. ### Avoid too long an input\n\nAll transformer models have a maximum input length size. For example, `bart-large-cnn` has a maximum limit of 1024 tokens, where each token is part of a word (i.e. a few characters).",
        "query": "How can I use a different summarization model from the Hugging Face Hub for my project?",
        "gold_answer": "To use a different summarization model from the Hugging Face Hub for your project, you would need to follow the guide linked in the context. This guide will provide you with the necessary steps to integrate a different model into your project. If you have your own models, you can upload them to Hugging Face as private modules and use them in your project. However, keep in mind that all transformer models have a maximum input length size, so you will need to ensure your input does not exceed this limit."
    },
    {
        "source": "We can then vectorize this text description using off-the-shelf models from OpenAI, Cohere, HuggingFace, and others to unlock semantic search. We recently presented an example of this idea for [AirBnB listings](https://weaviate.io/blog/generative-feedback-loops-with-llms), translating tabular data about each property\u2019s price, neighborhood, and more into a text description. Huge thanks to Svitlana Smolianova for creating the following animation of the concept. <img\n    src={require('./img/gen-example.gif').default}\n    alt=\"alt\"\n    style={{ width: \"100%\" }}\n/>\n\n### Text Chunking\nSimilarly related to the 512 token length for vectorizing text chunks, we may consider using the Large Language Model to identify good places to cut up text chunks. For example, if we have a list of items, it might not be best practice to separate the list into 2 chunks because the first half fell into the tail end of a chunk[:512] loop.",
        "query": "What is the strategy for chunking text for vectorization when dealing with a 512 token length limit?",
        "gold_answer": "The strategy for chunking text for vectorization when dealing with a 512 token length limit involves using a Large Language Model to identify suitable places to cut up text chunks. This process, known as \"chunking\", breaks down long documents into smaller sections, each containing an important piece of information. This approach not only helps to stay within the LLMs token limit but also enhances the retrieval of information. It's important to note that the chunking should be done thoughtfully, not just splitting a list of items into 2 chunks because the first half fell into the tail end of a chunk[:512] loop."
    },
    {
        "source": "You can find other dev container templates [here](https://containers.dev/templates). **Step 2. Test the Setup**\n\n1. After setting up the environment we tested that everything worked by:\nCreate a [dummy endpoint](https://github.com/weaviate/howto-weaviate-retrieval-plugin/commit/57c00bc85aea3a155d330f0de72525ee26a665d1#diff-c16fbf0c6f7b90a46b94b36f88893c2d174476088608841f7254afba0e81373d) which will simply respond with a `{\u201cHello\u201d: \u201cWorld\u201d}` object when called. ```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root():\n    \"\"\"\n    Say hello to the world\n    \"\"\"\n    return {\"Hello\": \"World\"}\n```\n\n2.",
        "query": "How do you create a dummy endpoint in FastAPI that returns `{\"Hello\": \"World\"}` when accessed?",
        "gold_answer": "To create a dummy endpoint in FastAPI that returns `{\"Hello\": \"World\"}` when accessed, you need to follow these steps:\n\n1. Import the FastAPI module: `from fastapi import FastAPI`\n2. Create an instance of the FastAPI class: `app = FastAPI()`\n3. Define a route that responds to HTTP GET requests at the root (\"/\") URL. This is done by using the `@app.get(\"/\")` decorator followed by a function that returns the desired message. The function could look like this:\n```python\ndef read_root():\n    \"\"\"\n    Say hello to the world\n    \"\"\"\n    return {\"Hello\": \"World\"}\n```\nSo, the complete code would look like this:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root():\n    \"\"\"\n    Say hello to the world\n    \"\"\"\n    return {\"Hello\": \"World\"}\n```\nWhen this code is run and the application is accessed at its root URL, it will respond with `{\"Hello\": \"World\"}`."
    },
    {
        "source": "Head to the [documentation](/developers/weaviate/configuration/backups) for a more in-depth overview and instructions. ## Reduced memory usage\n\n![Reduced memory usage](./img/reduced-memory-usage.jpg)\n\nAs part of the continuous effort to make Weaviate faster, leaner and more powerful, we introduced new optimizations to use less RAM without sacrificing performance. ### Thread pooling optimization\n\nFirst, we set our sights on parallel imports, where we introduced thread pooling to reduce memory spikes while importing data. Previously if you had, e.g., 8 CPUs and would import from 4 client threads, each client request would run with a parallelization factor of 8 (one per CPU core). So, in the worst case, you could end up with 32 parallel imports (on a machine with \"only\" 8 CPUs).",
        "query": "What optimization has Weaviate introduced to manage memory usage during parallel data imports?",
        "gold_answer": "Weaviate has introduced thread pooling optimization to manage memory usage during parallel data imports. This optimization ensures that the parallelization does not exceed the number of CPU cores, thus providing maximum performance without unnecessary memory usage."
    },
    {
        "source": "Similarly to the original Gorilla paper\u2019s use of Abstract Syntax Tree evaluation, we are also considering an n-gram match where we construct keywords for each query such as \u201cbm25\u201d, \u201cquery\u201d, \u201ctitle\u201d and check how many are contained in the generated query. We can also use the finer-grained perplexity metric that measures the log probability of the ground truth tokens at each step of decoding. We are currently using a simple greedy decoding algorithm to sample from the LoRA fine-tuned LlaMA 7B LLM. To ground the evaluation discussion further, let\u2019s take a look at an incorrect query:\n\n```graphql\n{\n\tGet {\n\t\tJobListing(\n\t\t\tbm25: {query: \u201csoftware\u201d}\n\t\t\twhere: {path: [\u201csalary\u201d], operator: GreaterThan, valueNumber: 50000}\n\t\t){\n\t\ttitle\n\t\tdescription\n\t\tisRemote\n\t\tpostedBy {\n\t\t\tname\n\t\t  }\n\t\t}\n\t}\n}\n```\n\nAlmost there! But unfortunately the missing comma from the `bm25` to `where` query will prevent this query from successfully executing. As discussed we may have other cases where although the syntax is correct and the query executes, it does not achieve what was specified in the natural language command.",
        "query": "What is the syntax error in the provided GraphQL query example related to the evaluation of n-gram matches?",
        "gold_answer": "The syntax error in the provided GraphQL query example is the missing comma between the `bm25` and `where` arguments in the `JobListing` function. This error could potentially affect the evaluation of n-gram matches by causing inaccurate keyword construction."
    },
    {
        "source": "#### Solution\nWe addressed each of the points above individually and improved the overall MTTR substantially:\n\n- A deduplication process was added, so that large WALs with a lot of updates (i.e. redundant data) could be reduced to only the necessary information. - The recovery process now runs in parallel. If there are multiple places that require recovery, they can each recover independently, without one recovery having to wait for the other. - A mechanism was added that flushes any memtable that has been idle (no writes) for 60s or more. In addition to speeding up the recovery, this change also ensures that no recovery is needed at all in many cases.",
        "query": "How was the MTTR improved in the system with regards to handling large write-ahead logs?",
        "gold_answer": "The MTTR was improved in the system by adding a deduplication process to reduce the size of the WALs, making the recovery process run in parallel, and adding a mechanism that flushes idle memtables. These changes resulted in a faster recovery process and in many cases, eliminated the need for recovery."
    },
    {
        "source": "---\ntitle: Weaviate 2023 Recap\nslug: 2023-recap\nauthors: [femke]\ndate: 2023-12-26\ntags: []\nimage: ./img/hero.png\ndescription: \"A reflection on 2023 from team Weaviate!\"\n---\n![hero](img/hero.png)\n\n<!-- truncate -->\n\nIt\u2019s hard to imagine that less than a year ago, so very few people even knew about the concept of vector databases and how AI could benefit from them. Those who did still had many questions about how they worked and whether they could at all be helpful. Meanwhile, curiosity and interest in AI spiked, especially after OpenAI launched ChatGPT. Curiosity has sped up our progress and made more people aware of the opportunities AI offers, transforming our landscape. Let's all take a moment to reflect and appreciate the start of a momentous change in how we can communicate, learn, teach, and collaborate so much faster and more effectively by leveraging AI.",
        "query": "What is the title of the Weaviate team's reflection on the year 2023?",
        "gold_answer": "The title of the Weaviate team's reflection on the year 2023 is \"Weaviate 2023 Recap\"."
    },
    {
        "source": "<br/>\nThen you could cross-reference it with another dashboard, to see that the slow down began when the import reached 120 million objects.<br/>\nIn two steps, you could narrow down the issue to a specific area, which would get you a lot closer to finding the solution. Or you could use that data to share it with the Weaviate team to get help. ### Try it yourserlf\nHere is an [example project](https://github.com/weaviate/weaviate-examples/tree/main/monitoring-prometheus-grafana), it contains:\n\n* `docker-compose.yml` that spins up Weaviate (without any modules),\n* a **Prometheus** instance,\n* and a **Grafana** instance. Just spin everything up, run a few queries and navigate to the Grafana instance in the browser to see the dashboard. ### Learn more\nTo learn more, see the [documentation](/developers/weaviate/configuration/monitoring).",
        "query": "At what number of imported objects did the slow down begin according to the document?",
        "gold_answer": "The slow down began at 120 million imported objects according to the document."
    },
    {
        "source": "1**: *Suppose we have vectors $x$ and $y$ represented in their original space. We apply a compression function $C$ to obtain a shorter representation of $x$ ($x'$) and $y$ ($y'$) on a compressed space but would require a decompression function $C'$ from the compressed space into the original space to be able to use the original distance function. In this case we would obtain $x''$ and $y''$ from $x'$ and $y'$ respectively and apply the distance on the approximations of the original $x$ and $y$ so $d(x,y)=d(x'',y'') + \\delta$ where $\\delta$ is the distortion added to the distance calculation due of the reconstruction of the original vectors. The compression/decompression mechanisms should be such that the distortion is minimized.*\n\n![comp2](./img/image2.jpg)\n**Fig. 2**: *Suppose we have vectors $x$ and $y$ represented in their original space.",
        "query": "What is the impact of vector compression and decompression on the accuracy of distance calculations between the original vectors?",
        "gold_answer": "The impact of vector compression and decompression on the accuracy of distance calculations between the original vectors is represented by the distortion term delta (\u03b4). This term represents the inaccuracy introduced into the distance calculation due to the reconstruction of the original vectors from their compressed forms. The goal of the compression and decompression mechanisms is to minimize this distortion, thereby maximizing the accuracy of the distance calculations."
    },
    {
        "source": "It is one of my favorite topics about Go memory management, and I'd be happy to write this post. Please let me know. For this one, it's enough to understand that sometimes heap-allocations happen even when we think they shouldn't. That is important to know because those allocations will put pressure on the GC, which is required for an unexpected OOM situation. ## Why would you run OOM \u2013 even when there is enough memory available?",
        "query": "Why can heap allocations in Go lead to out-of-memory errors even when there appears to be enough memory available?",
        "gold_answer": "Heap allocations in Go can lead to out-of-memory errors even when there appears to be enough memory available due to a combination of factors. These include unexpected heap allocations where temporary memory \"escapes\" onto the heap, inefficiencies in memory usage due to the Go runtime only being able to set relative GC targets before Go 1.19, and pressure on the Garbage Collector due to these unexpected heap allocations. These factors can lead to the Garbage Collector being unable to keep up with the rate of memory allocation, resulting in an out-of-memory situation."
    },
    {
        "source": "This pillar is all about performance. The first big step will be the move towards a [Native Roaring Bitmap Index](https://github.com/weaviate/weaviate/issues/2511). In the most extreme case, this new index time can speed up filtered vector search [by a factor of 1000](https://twitter.com/etiennedi/status/1621180981519458305). But it doesn\u2019t stop there; we are already thinking about the next steps. Whether you want faster aggregations or new types of specialized indexes, we will ensure you can hit all your p99 latency targets with Weaviate.",
        "query": "What is the expected performance improvement for filtered vector search in Weaviate with the new Native Roaring Bitmap Index?",
        "gold_answer": "The expected performance improvement for filtered vector search in Weaviate with the new Native Roaring Bitmap Index is up to a factor of 1000, in the most extreme case."
    },
    {
        "source": "This case is quite similar to our discussion of Multi-Index Routing and we can similarly evaluate generations with a prompt that explains the needs for SQL and Vector Databases and then asks the LLM whether the router made the right decision. We can also use the RAGAS Context Relevance score for the results of the SQL query. <img\n  src={require('./img/sql-router.png').default}\n  alt=\"SQL Router Query Engine\"\n  style={{ maxWidth: \"60%\" }}\n/>\n\nConcluding our discussion of \u201cFrom RAG to Agent Evaluation\u201d, we believe that it is still too early to tell what the common patterns will be for agent use. We have intentionally shown the multi-hop query engine and query router because these are relatively straightforward to understand. Once we add more open-ended planning loops, tool use and the associated evaluation of how well the model can format API requests to the tool, and more meta internal memory management prompts such as the ideas in MemGPT, it is very difficult to provide a general abstraction around how Agents will be evaluated.",
        "query": "What are the considerations for evaluating agents in the context of Multi-Index Routing and SQL and Vector Databases as discussed in the document?",
        "gold_answer": "The considerations for evaluating agents in the context of Multi-Index Routing and SQL and Vector Databases include the complexity of the agent's tasks, the relevance of the context in which the query is made, the ability of the agent to decompose a question into sub-questions and combine the answers to answer the original question, and the use of vector databases to provide LLMs with long-term memory."
    },
    {
        "source": "Send the relevant properties for vectorization to Cohere\n1. Store the data object and index the vector in Weaviate\n\n![Weaviate Import with Cohere](./img/cohere-import.png)\n\nThis allows Weaviate to efficiently store and query your data. ### Query\nWhen you query Weaviate, Weaviate will:\n1. Receive the query\n1. Send the query to Cohere to vectorize it\n1.",
        "query": "How does Weaviate process and vectorize queries using Cohere?",
        "gold_answer": "When Weaviate processes and vectorizes queries using Cohere, it follows these steps: \n1. Weaviate receives the query.\n2. The query is sent to Cohere for vectorization.\n3. Cohere vectorizes the data using Large Language Models.\n4. The returned query vector is used by Weaviate to search in the vector index.\n5. Weaviate returns the matched objects. \nThis process demonstrates a division of roles where Cohere handles the vectorization of the data and Weaviate manages the process, stores the data and vectors, and ensures production-ready performance."
    },
    {
        "source": "Typically this is in the context of recommendation in which we have metadata about users, as well as the documents or items. So for example, say we have features that describe a Users looking for Movies such as:\n\nUser Features - (Age, Gender, Location, Occupation, Preferences)\nMovie Features - (Release Year, Genre, Box Office, Duration). So together, the Metadata ranker takes as input something like: [Age, Gender, Location, Occupation, Preferences, Release year, Genre, Box Office, Duration] and predicts a score of how much this User will like the movie. We can fix the User features and rotate in each Document to get a score for each of the candidate movies (retrieved with something like ref2vec) to rank with. In addition to vectors, Weaviate also enables storing metadata features about objects such as `price`, or `color`.",
        "query": "How does the Metadata ranker predict which movies a user will like based on their personal features and movie characteristics?",
        "gold_answer": "The Metadata ranker predicts which movies a user will like by taking into account both user features (such as age, gender, location, occupation, and preferences) and movie features (such as release year, genre, box office, and duration). It fixes the user features and rotates in each movie to get a score for each of the candidate movies. This score is then used to rank the movies in order of predicted preference for the user, providing a personalized and context-aware recommendation."
    },
    {
        "source": "Please boost relevance based on recency and if the Author is \u201cConnor Shorten\u201d. ```\n\nEach search result then comes packaged with their associated metadata in a key-value array. This offers the additional benefit of allowing business practitioners to easily swap out the ranking logic. This also holds the benefit of dramatically increasing the interpretability of recommendation systems, since LLMs can easily be prompted to provide an explanation of the ranking in addition to the ranking itself. ## Search Result Compression\n\nTraditionally, search results are presented to human users as a long list of relevant websites or passages.",
        "query": "What are the benefits of packaging search results with associated metadata in a key-value array?",
        "gold_answer": "The benefits of packaging search results with associated metadata in a key-value array include the ability to easily swap out the ranking logic, increased interpretability of recommendation systems, and the provision of a more personalized and context-aware search experience."
    },
    {
        "source": "<div align=\"center\">\n\n![\"Bob talks about feedback loops\"](img/bob-gen-ai.jpg)\n##### Our CEO Bob talking about the next level of vector database capabilities - Generative Feedback Loops\n\n</div>\n\nWe also got tons of great feedback on our open-source RAG app, Verba, which we used to demo Weaviate. It\u2019s something you can use to quickly build RAG apps that fit your use case. Check out [our intro video](https://youtu.be/IiNDCPwmqF8?si=cZxfsnY6vW75c4BD) or dive right in to [our GitHub repo](https://youtu.be/IiNDCPwmqF8?si=cZxfsnY6vW75c4BD)!\n\n<div align=\"center\">\n\n![\"Adam demos Verba\"](img/adam-verba.jpg)\n##### Adam from our Developer Growth team demoing Verba, powered by Weaviate!\n\n</div>\n\nIt was great hearing about the different use cases and industries in which folks are building AI apps \u2013 these included chatbots and search applications for things like customer support, document search, image search, and even video search. A common pattern we saw was that organizations of all sizes are evaluating vector database platforms and want guidance on how to find the right database for them. One of our recommendations is to look for a vector database purpose-built for AI.",
        "query": "Who is the CEO that discussed the next level of vector database capabilities related to Generative Feedback Loops?",
        "gold_answer": "The CEO who discussed the next level of vector database capabilities related to Generative Feedback Loops is Bob."
    },
    {
        "source": "**Automatic Deserialization**: Thanks to the integration with Confluent's Schema Registry, the data in the Kafka message has been automatically deserialized. Each key in the message's data becomes its own property in the corresponding Weaviate object. For example, **`city`**, **`first_name`**, and **`last_name`** are all individual properties in Weaviate, making the data immediately usable for your AI applications. ## Closing CTAs\n\nNot yet a Weaviate customer? Kickstart your AI journey with a [free sandbox environment](https://console.weaviate.cloud/) in Weaviate Cloud Services today - no credit card required.",
        "query": "How does Weaviate handle Kafka message data with Confluent's Schema Registry integration?",
        "gold_answer": "Weaviate handles Kafka message data with Confluent's Schema Registry integration by automatically extracting the schema ID from the message's value and querying the Schema Registry to retrieve the associated schema. This schema is then used to deserialize the rest of the data, ensuring accurate data streaming into Weaviate. Each key in the Kafka message's data becomes its own property in the corresponding Weaviate object, making the data immediately usable for AI applications. Before streaming data into Weaviate, a schema is created in Weaviate to define the structure of the Kafka messages that will be stored."
    },
    {
        "source": "A dataset labeled for Question Answering is very different from Image Classification, or even Duplicate Question Detection. ### Task Benchmarks\nTwo excellent benchmarks that collect Supervised Learning tasks to evaluate Sentence Transformers are Knowledge Intensive Language Tasks ([KILT](https://ai.facebook.com/tools/kilt/)) and Benchmarking Information Retrieval ([BEIR](https://arxiv.org/abs/2104.08663)). **KILT** uses the same domain for all tasks, Wikipedia. Each task is labeled with a different task: Slot Filling, Question Answering, Dialogue, Fact Checking, or Entity Linking. ![KILT Benchmark](./img/KILT-min-correct.png)\n\n**BEIR** tests many different tasks: Fact Checking, Citation Prediction, Duplicate Question Retrieval, Argument Retrieval and more.",
        "query": "What are the tasks included in the KILT benchmark for evaluating Sentence Transformers?",
        "gold_answer": "The tasks included in the KILT benchmark for evaluating Sentence Transformers are Slot Filling, Question Answering, Dialogue, Fact Checking, and Entity Linking."
    },
    {
        "source": "---\ntitle: How to choose a Sentence Transformer from Hugging Face\nslug: how-to-choose-a-sentence-transformer-from-hugging-face\nauthors: [connor]\ndate: 2022-10-04\ntags: ['integrations']\nimage: ./img/hero.png\ndescription: \"Learn about the various Sentence Transformers from Hugging Face!\"\n---\n![How to choose a Sentence Transformer from Hugging Face](./img/hero.png)\n\n<!-- truncate -->\n\n[Weaviate](/developers/weaviate/) has recently unveiled a new module which allows users to easily [integrate models from Hugging Face](/blog/hugging-face-inference-api-in-weaviate) to vectorize their data and incoming queries. At the time of this writing, there are [over 700 models](https://huggingface.co/models?pipeline_tag=sentence-similarity&sort=downloads) that can be easily plugged into Weaviate. You may ask: **Why are there so many models and how do they differ?**<br/>\nAnd more importantly: **How to choose a Sentence Transformer for Semantic Search?**\n\nThere are too many models to summarize in one flowchart. So instead, we will describe factors that differentiate these models and give you tools to **choose the perfect model for your use case**. <img\n    src={require('./img/huggingface-sentence-transformers.png').default}\n    alt=\"Weaviate Sentence Transformers\"\n    style={{ maxWidth: \"70%\" }}\n/>\n\n## Differences in Deep Learning models\n\nNot too long ago, Deep Learning models were typically differentiated based on architectural decisions.",
        "query": "How do I choose the right Sentence Transformer model from Hugging Face for Semantic Search?",
        "gold_answer": "To choose the right Sentence Transformer model from Hugging Face for Semantic Search, you need to identify the model that was trained on the most similar domain and task to your use case. You can do this by looking at the color-coded details provided by Hugging Face for each model. Choose a model that was trained on a dataset that closely matches your domain and is in the same language as your data."
    },
    {
        "source": "With easy access to data streams from across their entire business, Weaviate users can now:\n\n* **Create a real-time knowledge base:**\nBuild a shared source of real-time truth for all your operational and analytical data, no matter where it lives for sophisticated model building and fine-tuning. Think business competitive analysis dashboards that are updated with latest market news updates. * **Bring real-time context at query time:**\nConvert raw data into meaningful chunks with real-time enrichment and continually update your embedding databases for your GenAI use cases. Think real-time filtering based on region, demographics, personas in online shopping, etc. * **Build governed, secured, and trusted AI:**\nEstablish data lineage, quality and traceability, providing all your teams with a clear understanding of data origin, movement, transformations and usage.",
        "query": "What are the new capabilities available to Weaviate users for managing their business data?",
        "gold_answer": "The new capabilities available to Weaviate users for managing their business data include creating a real-time knowledge base, bringing real-time context at query time, building governed, secured, and trusted AI, and a new backup feature that allows backing up and restoring data."
    }
]